//And everybody clapped.
/mob/living/basic/swarmer
	name = "swarmer"
	desc = "Malware of the space age. These robotic pests consume metal to create vapid structures to ensure their survival, and almost always come in groups."
	icon = 'surfshack13/icons/swarmers/swarmer.dmi'
	icon_state = "swarmer"
	icon_living = "swarmer"
	icon_dead = "swarmer_unactivated"
	death_message = "suddenly retracts into its shell, deactivating itself."
	health = 45
	maxHealth = 45
	unsuitable_atmos_damage = 0
	unsuitable_cold_damage = 0
	unsuitable_heat_damage = 0
	speed = 0
	density = FALSE
	pass_flags = PASSTABLE | PASSMOB
	sight = SEE_TURFS | SEE_OBJS | SEE_MOBS
	gender = NEUTER
	mob_biotypes = MOB_ROBOTIC
	initial_language_holder = /datum/language_holder/swarmer
	mob_size = MOB_SIZE_SMALL
	speak_emote = list("drones")
	speech_span = SPAN_ROBOT
	bubble_icon = "machine"
	damage_coeff = list(BRUTE = 1, BURN = 1, TOX = 0, STAMINA = 0, OXY = 0)
	hud_possible = list(DIAG_STAT_HUD, DIAG_HUD, ANTAG_HUD)
	unique_name = TRUE
	melee_damage_lower = 45
	melee_damage_upper = 45
	melee_attack_cooldown = CLICK_CD_MELEE
	obj_damage = 0
	attack_verb_continuous = "shocks"
	attack_verb_simple = "shock"
	attack_sound = 'sound/effects/empulse.ogg'
	melee_damage_type = STAMINA
	light_system = OVERLAY_LIGHT
	light_range = 3
	light_on = FALSE
	light_color = LIGHT_COLOR_CYAN
	hud_type = /datum/hud/living/swarmer
	/// The component we use for making ranged attacks
	var/datum/component/ranged_attacks/ranged_attacks
	///Resource points, generated by consuming metal/glass
	var/resources = 20
	///Maximum amount of resources a swarmer can store
	var/max_resources = 100

/mob/living/basic/swarmer/Initialize(mapload)
	. = ..()
	ranged_attacks = AddComponent(/datum/component/ranged_attacks, projectile_type = /obj/projectile/beam/disabler/swarmer, projectile_sound = 'sound/items/weapons/taser2.ogg')
	RegisterSignal(src, COMSIG_HOSTILE_PRE_ATTACKINGTARGET, PROC_REF(on_swarmer_pre_attack))
	remove_verb(src, /mob/living/verb/pulled)

	var/static/list/innate_actions = list(
		/datum/action/innate/swarmer/repair = "BB_swarmer_repair",
		/datum/action/innate/swarmer/contact_swarmers = "BB_swarmer_contact",
		/datum/action/innate/swarmer/toggle_lights = "BB_swarmer_toggle_light",
		/datum/action/innate/swarmer/fabricate_trap = "BB_swarmer_fabricate_trap",
		/datum/action/innate/swarmer/fabricate_blockcade = "BB_swarmer_fabricate_blockcade",
	)

	grant_actions_by_list(innate_actions)

/mob/living/basic/swarmer/mind_initialize()
	..()
	if(!mind.has_antag_datum(/datum/antagonist/swarmer))
		mind.add_antag_datum(/datum/antagonist/swarmer)

/mob/living/basic/swarmer/Login()
	. = ..()
	update_resource_display()

/mob/living/basic/swarmer/Destroy()
	QDEL_NULL(ranged_attacks)
	return ..()

/mob/living/basic/swarmer/get_status_tab_items()
	. = ..()
	. += "Resources: [resources]"

/mob/living/basic/swarmer/emp_act()
	. = ..()
	if(. & EMP_PROTECT_SELF)
		return
	if(health > 1)
		adjust_health(health-1)
	else
		death()

/mob/living/basic/swarmer/CanAllowThrough(atom/movable/mover, border_dir)
	. = ..()
	if(istype(mover, /obj/projectile/beam/disabler))//Allows for swarmers to fight as a group without wasting their shots hitting each other
		return TRUE
	else if(isswarmer(mover))
		return TRUE

/mob/living/basic/swarmer/proc/update_resource_value(amount_to_add)
	resources += amount_to_add
	if(amount_to_add > 0 && mind.has_antag_datum(/datum/antagonist/swarmer))
		var/datum/antagonist/swarmer/swarmer_datum = locate() in mind.antag_datums
		swarmer_datum.total_gained_resources += amount_to_add
	update_resource_display()

/mob/living/basic/swarmer/proc/update_resource_display()
	if(hud_used)
		hud_used.alien_plasma_display.maptext = MAPTEXT("<div align='center' valign='middle' style='position:relative; top:0px; left:6px'><font color='blue'>[resources]</font></div>")

/mob/living/basic/swarmer/proc/on_swarmer_pre_attack(mob/living/basic/swarmer/our_swarmer, atom/target, proximity, modifiers)
	SIGNAL_HANDLER

	if(LAZYACCESS(modifiers, RIGHT_CLICK) && isliving(target) && target != src)
		INVOKE_ASYNC(our_swarmer, PROC_REF(prepare_target), target)
		return COMPONENT_HOSTILE_NO_ATTACK

	if(isswarmer(target))
		INVOKE_ASYNC(our_swarmer, PROC_REF(attempt_revival), target)
		return COMPONENT_HOSTILE_NO_ATTACK
	if(!isliving(target))
		target.swarmer_act(src)
		return COMPONENT_HOSTILE_NO_ATTACK
	if(iscyborg(target))
		var/mob/living/silicon/borg = target
		borg.adjustBruteLoss(melee_damage_lower)

///Revive your pals
/mob/living/basic/swarmer/proc/attempt_revival(target)
	var/mob/living/basic/swarmer/swarmer_target = target
	if(swarmer_target.stat != DEAD)
		return
	to_chat(src, span_info("Attempting to jumpstart [target]'s power, please standby..."))
	if(!do_after(src, 20 SECONDS, target))
		return
	visible_message("[src] shocks [target], causing their power to turn back on and revive.", "You shock [target], rebooting their systems.")
	swarmer_target.revive(HEAL_ALL)

/**
 * Called when a swarmer creates a structure or drone
 *
 * Proc called whenever a swarmer creates a structure or drone
 * Arguments:
 * * fabrication_object - The atom to create
 * * fabrication_cost - How many resources it costs for a swarmer to create the object
 */
/mob/living/basic/swarmer/proc/Fabricate(atom/fabrication_object,fabrication_cost = 0)
	if(!isturf(loc))
		to_chat(src, span_warning("This is not a suitable location for fabrication. We need more space."))
		return
	if(resources < fabrication_cost)
		to_chat(src, span_warning("You do not have the necessary resources to fabricate this object."))
		return
	update_resource_value(-fabrication_cost)
	return new fabrication_object(drop_location())

/**
 * Called when a swarmer attempts to consume an object
 *
 * Proc which determines interaction between a swarmer and whatever it is attempting to consume
 * Arguments:
 * * target - The material or object the swarmer is attempting to consume
 */
/mob/living/basic/swarmer/proc/Integrate(obj/target)
	var/resource_gain = target.integrate_amount()
	if(resources + resource_gain > max_resources)
		to_chat(src, span_warning("We cannot hold more materials!"))
		return TRUE
	if(!resource_gain)
		to_chat(src, span_warning("[target] is incompatible with our internal matter recycler."))
		return FALSE
	update_resource_value(resource_gain)
	do_attack_animation(target)
	changeNext_move(CLICK_CD_RAPID)
	var/obj/effect/temp_visual/swarmer/integrate/I = new /obj/effect/temp_visual/swarmer/integrate(get_turf(target))
	I.pixel_x = target.pixel_x
	I.pixel_y = target.pixel_y
	I.pixel_z = target.pixel_z
	if(istype(target, /obj/item/stack))
		var/obj/item/stack/S = target
		S.use(1)
		if(S.amount)
			return TRUE
	qdel(target)
	return TRUE

/**
 * Called when a swarmer attempts to destroy a structure
 *
 * Proc which determines interaction between a swarmer and a structure it is destroying
 * Arguments:
 * * target - The material or object the swarmer is attempting to destroy
 */
/mob/living/basic/swarmer/proc/dis_integrate(atom/movable/target)
	new /obj/effect/temp_visual/swarmer/disintegration(get_turf(target))
	do_attack_animation(target)
	changeNext_move(CLICK_CD_MELEE)
	SSexplosions.low_mov_atom += target

/**
 * Called when a swarmer attempts to disassemble a machine
 *
 * Proc called when a swarmer attempts to disassemble a machine.  Destroys the machine, and gives the swarmer metal.
 * Arguments:
 * * target - The machine the swarmer is attempting to disassemble
 */
/mob/living/basic/swarmer/proc/dismantle_machine(obj/machinery/target)
	do_attack_animation(target)
	to_chat(src, span_info("We begin to dismantle this machine. We will need to be uninterrupted."))
	var/obj/effect/temp_visual/swarmer/dismantle/dismantle_effect = new /obj/effect/temp_visual/swarmer/dismantle(get_turf(target))
	dismantle_effect.pixel_x = target.pixel_x
	dismantle_effect.pixel_y = target.pixel_y
	dismantle_effect.pixel_z = target.pixel_z
	if(do_after(src, 10 SECONDS, target))
		to_chat(src, span_info("Dismantling complete."))
		var/atom/target_loc = target.drop_location()
		new /obj/item/stack/sheet/iron(target_loc, 5)
		var/obj/effect/temp_visual/swarmer/disintegration/disintegration_effect = new /obj/effect/temp_visual/swarmer/disintegration(get_turf(target))
		disintegration_effect.pixel_x = target.pixel_x
		disintegration_effect.pixel_y = target.pixel_y
		disintegration_effect.pixel_z = target.pixel_z
		target.dump_contents()
		if(istype(target, /obj/machinery/computer))
			var/obj/machinery/computer/computer_target = target
			if(computer_target.circuit)
				computer_target.circuit.forceMove(target_loc)
		qdel(target)

/**
 * Called when a swarmer attempts to teleport a living entity away
 *
 * Proc which finds a safe location to teleport a living entity to when a swarmer teleports it away.  Also energy handcuffs carbons.
 * Arguments:
 * * target - The entity the swarmer is trying to teleport away
 */
/mob/living/basic/swarmer/proc/prepare_target(mob/living/target)
	if(target == src)
		return

	if(!is_station_level(z) && !is_mining_level(z))
		to_chat(src, span_warning("Our bluespace transceiver cannot locate a viable bluespace link, our teleportation abilities are useless in this area."))
		return

	to_chat(src, span_info("Attempting to remove this being from our presence."))

	if(!do_after(src, 3 SECONDS, target))
		return

	teleport_target(target)

//When the swarmer needs something to go elsewhere.
/mob/living/basic/swarmer/proc/teleport_target(mob/living/target)
	var/turf/open/floor/safe_turf = find_safe_turf(zlevels = z, extended_safety_checks = TRUE)

	if(!safe_turf)
		return
	// If we're getting rid of a human, slap some energy cuffs on
	// them to keep them away from us a little longer

	if(ishuman(target))
		var/mob/living/carbon/human/victim = target
		if(!victim.handcuffed)
			victim.set_handcuffed(new /obj/item/restraints/handcuffs/energy/used(victim))
			victim.update_handcuffed()
			log_combat(src, victim, "handcuffed")

	var/datum/effect_system/spark_spread/sparks = new
	sparks.set_up(4,0,get_turf(target))
	sparks.start()
	playsound(src, 'sound/effects/sparks/sparks4.ogg', 50, TRUE)
	do_teleport(target, safe_turf , 0, channel = TELEPORT_CHANNEL_BLUESPACE)

//Swarmer disabler projectile
/obj/projectile/beam/disabler/swarmer/on_hit(atom/target, blocked = FALSE, pierce_hit)
	. = ..()
	if(!.)
		return
	if((!isanimal(target) && !ishuman(target) && !isbasicmob(target)) || isswarmer(target))
		return
	if(ishuman(target))
		var/mob/living/carbon/human/possibleHulk = target
		if(!possibleHulk.dna || !possibleHulk.dna.check_mutation(/datum/mutation/human/hulk))
			return
	var/mob/living/basic/swarmer/swarmer = firer
	swarmer.teleport_target(target)
